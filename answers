CMPUT 313
Assignment 1

Part 1:
1.
The basic data types that are not structs or enums are the following.
CnetAddr
CnetColour
CnetData
CnetRandom
CnetTime
CnetTimerID

An int on the lab machine is 4 bytes/32 bits.
The only 32 bit integers in the above types are the CnetAddr and CnetTimerID.
All others are either void pointers, char pointers, input vars pointer or 64 bit ints.

2.
The node time is stored in the nodeinfo.time_in_usec variable.
You can print this variable using printf:

printf("Node time is %lld", nodeinfo.time_in_usec);

3.
You are able to specify minimum and maximum message sizes, however cnet.h does not specify
the content/format of the messages sent.

4.
By enveloping cnet library calls in a check statement, if an error occurs you can get the source file, line number and nodename of where the error occured. 

Since the check macro auto exits on failure the easiest way to continue execution but get the error information is to test the return value of each library function, if the return value does not equal zero it indicates an error occured. To find information on the error you can index into the cnet_errstr array using the global cnet_errno which each library function sets on errors.

printf("The error message was: %s", cnet_errstr[cnet_errno]);

You could also use the CNET_perror(char *prefix) function after checking if a library function returned with errors. This function prints the last error message with a user supplied prefix.

5.
It will happen whenever the message len is not of size MAX_MESSAGE_SIZE.
Furthermore, depending on the bit packing and MAX_MESSAGE_SIZE its possible that even if len matched 
the MAX_MESSAGE_SIZE they would still not be equal.

6.
Yes. f.checksum is set prior to sending by the CNET_ccitt function.
f.checksum = CNET_ccitt((unsigned char *)&f, (int)length);

The physical_ready handler checks that the checksum is correct with the
same function used to determine the checksum on sending.
CNET_ccitt((unsigned char *)&f, (int)len) != checksum)
if correct the handler goes on to write the frame to the application layer. 
If the checksum is bad the frame is thrown out.

7.
When data is transmitted in the transmit_frame handler a timer is started with
lasttimer = CNET_start_timer(EV_TIMER1, 3 * timeout, 0);

Once a data frame is read in the physical_ready handler the following code stops the timer.
CNET_stop_timer(lasttimer);
